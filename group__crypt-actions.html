<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cryptsetup API: Cryptsetup device context actions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cryptsetup API
   </div>
   <div id="projectbrief">Public cryptsetup API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cryptsetup device context actions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac20a652f4ccb8c1b3993d3f278999198"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gac20a652f4ccb8c1b3993d3f278999198">CRYPT_COMPAT_LEGACY_INTEGRITY_PADDING</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:gac20a652f4ccb8c1b3993d3f278999198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe516652db3659c429f716b2fcc7ee41"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gabe516652db3659c429f716b2fcc7ee41">CRYPT_COMPAT_LEGACY_INTEGRITY_HMAC</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:gabe516652db3659c429f716b2fcc7ee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbb01d4ef02b3ce48251cdc730e3aa1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gaacbb01d4ef02b3ce48251cdc730e3aa1">CRYPT_COMPAT_LEGACY_INTEGRITY_RECALC</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="separator:gaacbb01d4ef02b3ce48251cdc730e3aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7ae085869e1bc17d9abde6cb3f588467"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga7ae085869e1bc17d9abde6cb3f588467">crypt_format</a> (struct crypt_device *cd, const char *type, const char *cipher, const char *cipher_mode, const char *uuid, const char *volume_key, size_t volume_key_size, void *params)</td></tr>
<tr class="separator:ga7ae085869e1bc17d9abde6cb3f588467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174ad1124660b346f0416081fdc753ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga174ad1124660b346f0416081fdc753ce">crypt_set_compatibility</a> (struct crypt_device *cd, uint32_t flags)</td></tr>
<tr class="separator:ga174ad1124660b346f0416081fdc753ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad2144cd56226a0e32e11393e4da3514"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gaad2144cd56226a0e32e11393e4da3514">crypt_get_compatibility</a> (struct crypt_device *cd)</td></tr>
<tr class="separator:gaad2144cd56226a0e32e11393e4da3514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad53a419672da11f794a7b10b8b7e2500"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gad53a419672da11f794a7b10b8b7e2500">crypt_convert</a> (struct crypt_device *cd, const char *type, void *params)</td></tr>
<tr class="separator:gad53a419672da11f794a7b10b8b7e2500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e103cb799c54fed072c2e0fccb804fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga1e103cb799c54fed072c2e0fccb804fb">crypt_set_uuid</a> (struct crypt_device *cd, const char *uuid)</td></tr>
<tr class="separator:ga1e103cb799c54fed072c2e0fccb804fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf105dc378c21a6764173391a4e9489"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gaddf105dc378c21a6764173391a4e9489">crypt_set_label</a> (struct crypt_device *cd, const char *label, const char *subsystem)</td></tr>
<tr class="separator:gaddf105dc378c21a6764173391a4e9489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df2c0dff64b5747488507c61eabb888"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga6df2c0dff64b5747488507c61eabb888">crypt_volume_key_keyring</a> (struct crypt_device *cd, int enable)</td></tr>
<tr class="separator:ga6df2c0dff64b5747488507c61eabb888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af2ba4a33a3be8b1abc6248292f7b16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga7af2ba4a33a3be8b1abc6248292f7b16">crypt_load</a> (struct crypt_device *cd, const char *requested_type, void *params)</td></tr>
<tr class="separator:ga7af2ba4a33a3be8b1abc6248292f7b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7df16d0dcd83b0438e0334b63c2b954"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gaa7df16d0dcd83b0438e0334b63c2b954">crypt_repair</a> (struct crypt_device *cd, const char *requested_type, void *params)</td></tr>
<tr class="separator:gaa7df16d0dcd83b0438e0334b63c2b954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168bcd5097cdf64774540fdeaacefbc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga168bcd5097cdf64774540fdeaacefbc0">crypt_resize</a> (struct crypt_device *cd, const char *name, uint64_t new_size)</td></tr>
<tr class="separator:ga168bcd5097cdf64774540fdeaacefbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b71c045168dc77b26b4fefe1d635b45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga0b71c045168dc77b26b4fefe1d635b45">crypt_suspend</a> (struct crypt_device *cd, const char *name)</td></tr>
<tr class="separator:ga0b71c045168dc77b26b4fefe1d635b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89fa408927e5a9025b6bd14a46f548f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gad89fa408927e5a9025b6bd14a46f548f">crypt_resume_by_passphrase</a> (struct crypt_device *cd, const char *name, int keyslot, const char *passphrase, size_t passphrase_size)</td></tr>
<tr class="separator:gad89fa408927e5a9025b6bd14a46f548f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220bd395417d881aad0a6484695aff68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga220bd395417d881aad0a6484695aff68">crypt_resume_by_keyfile_device_offset</a> (struct crypt_device *cd, const char *name, int keyslot, const char *keyfile, size_t keyfile_size, uint64_t keyfile_offset)</td></tr>
<tr class="separator:ga220bd395417d881aad0a6484695aff68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d3d7158a7790a69ddb32b919f68118"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gaa6d3d7158a7790a69ddb32b919f68118">crypt_resume_by_keyfile_offset</a> (struct crypt_device *cd, const char *name, int keyslot, const char *keyfile, size_t keyfile_size, size_t keyfile_offset)</td></tr>
<tr class="separator:gaa6d3d7158a7790a69ddb32b919f68118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefcc77dbab2557a426c64f9ee1350e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#gaeefcc77dbab2557a426c64f9ee1350e4">crypt_resume_by_keyfile</a> (struct crypt_device *cd, const char *name, int keyslot, const char *keyfile, size_t keyfile_size)</td></tr>
<tr class="separator:gaeefcc77dbab2557a426c64f9ee1350e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fda4144db129704be77241e01003c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crypt-actions.html#ga54fda4144db129704be77241e01003c2">crypt_resume_by_volume_key</a> (struct crypt_device *cd, const char *name, const char *volume_key, size_t volume_key_size)</td></tr>
<tr class="separator:ga54fda4144db129704be77241e01003c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Set of functions for formatting and manipulating with specific crypt_type </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gabe516652db3659c429f716b2fcc7ee41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe516652db3659c429f716b2fcc7ee41">&#9670;&nbsp;</a></span>CRYPT_COMPAT_LEGACY_INTEGRITY_HMAC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPT_COMPAT_LEGACY_INTEGRITY_HMAC&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dm-integrity device does not protect superblock with HMAC (old kernels) </p>

</div>
</div>
<a id="gac20a652f4ccb8c1b3993d3f278999198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac20a652f4ccb8c1b3993d3f278999198">&#9670;&nbsp;</a></span>CRYPT_COMPAT_LEGACY_INTEGRITY_PADDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPT_COMPAT_LEGACY_INTEGRITY_PADDING&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dm-integrity device uses less effective (legacy) padding (old kernels) </p>

</div>
</div>
<a id="gaacbb01d4ef02b3ce48251cdc730e3aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacbb01d4ef02b3ce48251cdc730e3aa1">&#9670;&nbsp;</a></span>CRYPT_COMPAT_LEGACY_INTEGRITY_RECALC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPT_COMPAT_LEGACY_INTEGRITY_RECALC&#160;&#160;&#160;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dm-integrity allow recalculating of volumes with HMAC keys (old kernels) </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad53a419672da11f794a7b10b8b7e2500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad53a419672da11f794a7b10b8b7e2500">&#9670;&nbsp;</a></span>crypt_convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_convert </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert to new type for already existing device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">type</td><td>type of device (optional params struct must be of this type) </td></tr>
    <tr><td class="paramname">params</td><td>crypt type specific parameters (see <a class="el" href="group__crypt-type.html">crypt-type</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or negative errno value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently, only LUKS1-&gt;LUKS2 and LUKS2-&gt;LUKS1 conversions are supported. Not all LUKS2 devices may be converted back to LUKS1. To make such a conversion possible all active LUKS2 keyslots must be in LUKS1 compatible mode (i.e. pbkdf type must be PBKDF2) and device cannot be formatted with any authenticated encryption mode.</dd>
<dd>
Device must be offline for conversion. UUID change is not possible for active devices. </dd></dl>

</div>
</div>
<a id="ga7ae085869e1bc17d9abde6cb3f588467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ae085869e1bc17d9abde6cb3f588467">&#9670;&nbsp;</a></span>crypt_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_format </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cipher_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>volume_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>volume_key_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create (format) new crypt device (and possible header on-disk) but do not activate it.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>cd</em> contains initialized and not formatted device context (device type must <b>not</b> be set)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">type</td><td>type of device (optional params struct must be of this type) </td></tr>
    <tr><td class="paramname">cipher</td><td>(e.g. "aes") </td></tr>
    <tr><td class="paramname">cipher_mode</td><td>including IV specification (e.g. "xts-plain") </td></tr>
    <tr><td class="paramname">uuid</td><td>requested UUID or <em>NULL</em> if it should be generated </td></tr>
    <tr><td class="paramname">volume_key</td><td>pre-generated volume key or <em>NULL</em> if it should be generated (only for LUKS) </td></tr>
    <tr><td class="paramname">volume_key_size</td><td>size of volume key in bytes. </td></tr>
    <tr><td class="paramname">params</td><td>crypt type specific parameters (see <a class="el" href="group__crypt-type.html">crypt-type</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>0</em> on success or negative errno value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that crypt_format does not create LUKS keyslot (any version). To create keyslot call any crypt_keyslot_add_* function. </dd>
<dd>
For VERITY <a class="el" href="group__crypt-type.html">crypt-type</a>, only uuid parameter is used, other parameters are ignored and verity specific attributes are set through mandatory params option. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="crypt_luks_usage_8c-example.html#a2">crypt_luks_usage.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaad2144cd56226a0e32e11393e4da3514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad2144cd56226a0e32e11393e4da3514">&#9670;&nbsp;</a></span>crypt_get_compatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t crypt_get_compatibility </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get compatibility flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compatibility flags </dd></dl>

</div>
</div>
<a id="ga7af2ba4a33a3be8b1abc6248292f7b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7af2ba4a33a3be8b1abc6248292f7b16">&#9670;&nbsp;</a></span>crypt_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_load </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>requested_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load crypt device parameters from on-disk header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">requested_type</td><td><a class="el" href="group__crypt-type.html">crypt-type</a> or <em>NULL</em> for all known </td></tr>
    <tr><td class="paramname">params</td><td>crypt type specific parameters (see <a class="el" href="group__crypt-type.html">crypt-type</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or negative errno value otherwise.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>In case LUKS header is read successfully but payload device is too small error is returned and device type in context is set to <em>NULL</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that in current version load works only for LUKS and VERITY device type. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="crypt_luks_usage_8c-example.html#a9">crypt_luks_usage.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaa7df16d0dcd83b0438e0334b63c2b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7df16d0dcd83b0438e0334b63c2b954">&#9670;&nbsp;</a></span>crypt_repair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_repair </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>requested_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to repair crypt device LUKS on-disk header if invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">requested_type</td><td><a class="el" href="group__crypt-type.html">crypt-type</a> or <em>NULL</em> for all known </td></tr>
    <tr><td class="paramname">params</td><td>crypt type specific parameters (see <a class="el" href="group__crypt-type.html">crypt-type</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or negative errno value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For LUKS2 device crypt_repair bypass blkid checks and perform auto-recovery even though there're third party device signatures found by blkid probes. Currently the crypt_repair on LUKS2 works only if exactly one header checksum does not match or exactly one header is missing. </dd></dl>

</div>
</div>
<a id="ga168bcd5097cdf64774540fdeaacefbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga168bcd5097cdf64774540fdeaacefbc0">&#9670;&nbsp;</a></span>crypt_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_resize </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize crypt device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>- crypt device handle </td></tr>
    <tr><td class="paramname">name</td><td>- name of device to resize </td></tr>
    <tr><td class="paramname">new_size</td><td>- new device size in sectors or <em>0</em> to use all of the underlying device size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>0</em> on success or negative errno value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Most notably it returns -EPERM when device was activated with volume key in kernel keyring and current device handle (context) doesn't have verified key loaded in kernel. To load volume key for already active device use any of <a class="el" href="group__crypt-activation.html#ga67fd5a62c320553d8cbfe32d0642537d">crypt_activate_by_passphrase</a>, <a class="el" href="group__crypt-activation.html#gaad28665fd5ab1c82ec3e64f401dc61ee">crypt_activate_by_keyfile</a>, <a class="el" href="group__crypt-activation.html#gaa83f0c67cd40f18c0165fc8129af73d5">crypt_activate_by_keyfile_offset</a>, <a class="el" href="group__crypt-activation.html#gaa63a70aed521f9ba8b0cc3f8c4ffd31b">crypt_activate_by_volume_key</a>, <a class="el" href="group__crypt-activation.html#gaefae4676e4bc90d321e6711a953b83e0">crypt_activate_by_keyring</a> or <a class="el" href="group__crypt-tokens.html#gaf6b9bbca3dd72cf7918e3e0a7063a28f">crypt_activate_by_token</a> with flag <em>CRYPT_ACTIVATE_KEYRING_KEY</em> raised and <em>name</em> parameter set to <em>NULL</em>. </dd></dl>

</div>
</div>
<a id="gaeefcc77dbab2557a426c64f9ee1350e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeefcc77dbab2557a426c64f9ee1350e4">&#9670;&nbsp;</a></span>crypt_resume_by_keyfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_resume_by_keyfile </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyslot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyfile_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward compatible <a class="el" href="group__crypt-actions.html#ga220bd395417d881aad0a6484695aff68">crypt_resume_by_keyfile_device_offset()</a> (without offset). </p>

</div>
</div>
<a id="ga220bd395417d881aad0a6484695aff68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga220bd395417d881aad0a6484695aff68">&#9670;&nbsp;</a></span>crypt_resume_by_keyfile_device_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_resume_by_keyfile_device_offset </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyslot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyfile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>keyfile_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resume crypt device using key file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">name</td><td>name of device to resume </td></tr>
    <tr><td class="paramname">keyslot</td><td>requested keyslot or CRYPT_ANY_SLOT </td></tr>
    <tr><td class="paramname">keyfile</td><td>key file used to unlock volume key </td></tr>
    <tr><td class="paramname">keyfile_size</td><td>number of bytes to read from keyfile, 0 is unlimited </td></tr>
    <tr><td class="paramname">keyfile_offset</td><td>number of bytes to skip at start of keyfile</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unlocked key slot number or negative errno otherwise. </dd></dl>

</div>
</div>
<a id="gaa6d3d7158a7790a69ddb32b919f68118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d3d7158a7790a69ddb32b919f68118">&#9670;&nbsp;</a></span>crypt_resume_by_keyfile_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_resume_by_keyfile_offset </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyslot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyfile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyfile_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward compatible <a class="el" href="group__crypt-actions.html#ga220bd395417d881aad0a6484695aff68">crypt_resume_by_keyfile_device_offset()</a> (with size_t offset). </p>

</div>
</div>
<a id="gad89fa408927e5a9025b6bd14a46f548f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89fa408927e5a9025b6bd14a46f548f">&#9670;&nbsp;</a></span>crypt_resume_by_passphrase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_resume_by_passphrase </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyslot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>passphrase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>passphrase_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resume crypt device using passphrase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">name</td><td>name of device to resume </td></tr>
    <tr><td class="paramname">keyslot</td><td>requested keyslot or CRYPT_ANY_SLOT </td></tr>
    <tr><td class="paramname">passphrase</td><td>passphrase used to unlock volume key </td></tr>
    <tr><td class="paramname">passphrase_size</td><td>size of <em>passphrase</em> (binary data)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unlocked key slot number or negative errno otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only LUKS device type is supported </dd></dl>

</div>
</div>
<a id="ga54fda4144db129704be77241e01003c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54fda4144db129704be77241e01003c2">&#9670;&nbsp;</a></span>crypt_resume_by_volume_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_resume_by_volume_key </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>volume_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>volume_key_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resume crypt device using provided volume key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">name</td><td>name of device to resume </td></tr>
    <tr><td class="paramname">volume_key</td><td>provided volume key </td></tr>
    <tr><td class="paramname">volume_key_size</td><td>size of volume_key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>0</em> on success or negative errno value otherwise. </dd></dl>

</div>
</div>
<a id="ga174ad1124660b346f0416081fdc753ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174ad1124660b346f0416081fdc753ce">&#9670;&nbsp;</a></span>crypt_set_compatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crypt_set_compatibility </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set format compatibility flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">flags</td><td>CRYPT_COMPATIBILITY_* flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaddf105dc378c21a6764173391a4e9489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddf105dc378c21a6764173391a4e9489">&#9670;&nbsp;</a></span>crypt_set_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_set_label </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subsystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set new labels (label and subsystem) for already existing device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">label</td><td>requested label or <em>NULL</em> </td></tr>
    <tr><td class="paramname">subsystem</td><td>requested subsystem label or <em>NULL</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or negative errno value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently, only LUKS2 device type is supported </dd></dl>

</div>
</div>
<a id="ga1e103cb799c54fed072c2e0fccb804fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e103cb799c54fed072c2e0fccb804fb">&#9670;&nbsp;</a></span>crypt_set_uuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_set_uuid </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uuid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set new UUID for already existing device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle </td></tr>
    <tr><td class="paramname">uuid</td><td>requested UUID or <em>NULL</em> if it should be generated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or negative errno value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently, only LUKS device type are supported </dd></dl>

</div>
</div>
<a id="ga0b71c045168dc77b26b4fefe1d635b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b71c045168dc77b26b4fefe1d635b45">&#9670;&nbsp;</a></span>crypt_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_suspend </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspend crypt device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle, can be <em>NULL</em> </td></tr>
    <tr><td class="paramname">name</td><td>name of device to suspend</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or negative errno value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only LUKS device type is supported </dd></dl>

</div>
</div>
<a id="ga6df2c0dff64b5747488507c61eabb888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6df2c0dff64b5747488507c61eabb888">&#9670;&nbsp;</a></span>crypt_volume_key_keyring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crypt_volume_key_keyring </td>
          <td>(</td>
          <td class="paramtype">struct crypt_device *&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable loading of volume keys via kernel keyring. When set to 'enabled' library loads key in kernel keyring first and pass the key description to dm-crypt instead of binary key copy. If set to 'disabled' library fallbacks to old method of loading volume key directly in dm-crypt target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>crypt device handle, can be <em>NULL</em> </td></tr>
    <tr><td class="paramname">enable</td><td>0 to disable loading of volume keys via kernel keyring (classical method) otherwise enable it (default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>0</em> on success or negative errno value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently loading of volume keys via kernel keyring is supported (and enabled by default) only for LUKS2 devices. </dd>
<dd>
The switch is global on the library level. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 24 2022 15:30:42 for cryptsetup API by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
